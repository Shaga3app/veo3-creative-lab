/**
 * ================================
 *  FINAL – STABLE – WORKING BUILD
 * ================================
 * Shaga3app Veo Video Generator (Vertex AI → S3)
 *
 * ✔ Google WIF auth (GOOGLE_WIF_JSON → /tmp creds)
 * ✔ Vertex AI Veo 3.1 long-running generate
 * ✔ Poll operation → decode base64 MP4
 * ✔ Upload MP4 to S3 (SigV4, no aws-sdk)
 * ✔ Return presigned GET URL (supports session token)
 * ✔ CORS handled by Lambda Function URL settings (avoid duplicate headers)
 *
 * Security:
 * ✔ Optional X-API-KEY protection (ONLY if VEO3_API_KEY env var is set)
 *
 * Last verified: 2025-12-23
 */

import fs from "fs";
import crypto from "crypto";
import { GoogleAuth } from "google-auth-library";
import fetch from "node-fetch";

// ✅ ADD (MongoDB driver import)
import { MongoClient } from "mongodb";

/* =========================
   Google credentials (WIF)
========================= */
function ensureGoogleCredsFile() {
  if (process.env.GOOGLE_APPLICATION_CREDENTIALS) return;

  const raw = process.env.GOOGLE_WIF_JSON;
  if (!raw) throw new Error("Missing GOOGLE_WIF_JSON env var");

  const path = "/tmp/gcp-wif-creds.json";
  fs.writeFileSync(path, raw, "utf8");
  process.env.GOOGLE_APPLICATION_CREDENTIALS = path;
}

/* =========================
   Base headers
   (CORS is handled by Function URL settings)
========================= */
function baseHeaders() {
  return { "Content-Type": "application/json" };
}

/* =========================
   OPTIONAL API KEY GUARD
   - If VEO3_API_KEY is NOT set => no auth required (works now)
   - If VEO3_API_KEY is set => webview must send header x-api-key
========================= */
function maybeRequireApiKey(event) {
  const expected = process.env.VEO3_API_KEY;
  if (!expected) return; // ✅ not enabled yet

  const h = event?.headers || {};
  // Lambda headers can be different casing; normalize:
  const got =
    h["x-api-key"] ||
    h["X-API-KEY"] ||
    h["X-Api-Key"] ||
    h["x-api-key".toLowerCase()];

  if (!got || got !== expected) {
    const err = new Error("Unauthorized");
    err.statusCode = 401;
    throw err;
  }
}

/* =========================
   AWS SigV4 helpers (NO aws-sdk)
========================= */
function hmac(key, str) {
  return crypto.createHmac("sha256", key).update(str, "utf8").digest();
}
function sha256Hex(data) {
  return crypto.createHash("sha256").update(data).digest("hex");
}
function amzDate(d) {
  return d.toISOString().replace(/[:-]|\.\d{3}/g, "");
}
function dateStamp(d) {
  return d.toISOString().slice(0, 10).replace(/-/g, "");
}
function signingKey(secret, date, region, service) {
  const kDate = hmac("AWS4" + secret, date);
  const kRegion = hmac(kDate, region);
  const kService = hmac(kRegion, service);
  return hmac(kService, "aws4_request");
}

/* =========================
   ✅ ADD — MongoDB rate limiting (server-side, persists across refresh)
   Uses:
   - MONGODB_URI
   - MONGODB_DB (default: ai_video_lab)
   - MONGODB_RATE_COLLECTION (default: rate_limits)
   - MAX_TRIALS (default: 2)
========================= */
let _mongoClient; // cached across Lambda warm invocations

async function getMongoClient() {
  if (_mongoClient) return _mongoClient;

  const uri = process.env.MONGODB_URI;
  if (!uri) throw new Error("Missing MONGODB_URI env var");

  _mongoClient = new MongoClient(uri, {
    maxPoolSize: 2,
    serverSelectionTimeoutMS: 5000,
  });

  await _mongoClient.connect();
  return _mongoClient;
}

// Default: 2 trials per 24h per deviceId
async function enforceTrials(deviceId) {
  const MAX_TRIALS = Number(process.env.MAX_TRIALS || 2);

  const dbName = process.env.MONGODB_DB || "ai_video_lab";
  const colName = process.env.MONGODB_RATE_COLLECTION || "rate_limits";

  const client = await getMongoClient();
  const col = client.db(dbName).collection(colName);

  const now = new Date();

  // 24h rolling window (simple + effective)
  const windowMs = 24 * 60 * 60 * 1000;
  const windowStart = new Date(now.getTime() - windowMs);

  // Count generate events within last 24h
  const count = await col.countDocuments({
    deviceId,
    kind: "generate",
    createdAt: { $gte: windowStart },
  });

  if (count >= MAX_TRIALS) {
    const err = new Error("TRIAL_LIMIT_REACHED");
    err.statusCode = 429;
    throw err;
  }

  // Record this generate attempt
  await col.insertOne({
    deviceId,
    kind: "generate",
    createdAt: now,
  });
}

/* =========================
   ✅ ADD — Trial status (for UI sync after refresh)
   Returns: maxTrials / used / left / windowHours
========================= */
async function getTrialStatus(deviceId) {
  const MAX_TRIALS = Number(process.env.MAX_TRIALS || 2);

  const dbName = process.env.MONGODB_DB || "ai_video_lab";
  const colName = process.env.MONGODB_RATE_COLLECTION || "rate_limits";

  const client = await getMongoClient();
  const col = client.db(dbName).collection(colName);

  const now = new Date();
  const windowMs = 24 * 60 * 60 * 1000;
  const windowStart = new Date(now.getTime() - windowMs);

  const used = await col.countDocuments({
    deviceId,
    kind: "generate",
    createdAt: { $gte: windowStart },
  });

  const left = Math.max(0, MAX_TRIALS - used);

  return { maxTrials: MAX_TRIALS, used, left, windowHours: 24 };
}

/* =========================
   S3 PUT upload (signed)
========================= */
async function s3Put({ region, bucket, key, body }) {
  const AK = process.env.AWS_ACCESS_KEY_ID;
  const SK = process.env.AWS_SECRET_ACCESS_KEY;
  const ST = process.env.AWS_SESSION_TOKEN;

  if (!AK || !SK) throw new Error("Missing AWS credentials");
  if (!region) throw new Error("Missing S3_REGION env var");
  if (!bucket) throw new Error("Missing S3_BUCKET env var");

  const service = "s3";
  const method = "PUT";
  const host = `${bucket}.s3.${region}.amazonaws.com`;
  const uri = `/${encodeURIComponent(key).replace(/%2F/g, "/")}`;

  const now = new Date();
  const amz = amzDate(now);
  const date = dateStamp(now);
  const payloadHash = sha256Hex(body);

  const headersToSign = {
    host,
    "x-amz-date": amz,
    "x-amz-content-sha256": payloadHash,
    "content-type": "video/mp4",
  };
  if (ST) headersToSign["x-amz-security-token"] = ST;

  const signedHeaders = Object.keys(headersToSign).sort().join(";");
  const canonicalHeaders = Object.keys(headersToSign)
    .sort()
    .map((k) => `${k}:${headersToSign[k]}\n`)
    .join("");

  const canonicalRequest =
    `${method}\n${uri}\n\n${canonicalHeaders}\n${signedHeaders}\n${payloadHash}`;

  const scope = `${date}/${region}/${service}/aws4_request`;
  const stringToSign =
    `AWS4-HMAC-SHA256\n${amz}\n${scope}\n${sha256Hex(canonicalRequest)}`;

  const sig = crypto
    .createHmac("sha256", signingKey(SK, date, region, service))
    .update(stringToSign)
    .digest("hex");

  const auth =
    `AWS4-HMAC-SHA256 Credential=${AK}/${scope}, SignedHeaders=${signedHeaders}, Signature=${sig}`;

  const putHeaders = {
    Authorization: auth,
    "x-amz-date": amz,
    "x-amz-content-sha256": payloadHash,
    "Content-Type": "video/mp4",
  };
  if (ST) putHeaders["x-amz-security-token"] = ST;

  const r = await fetch(`https://${host}${uri}`, {
    method: "PUT",
    headers: putHeaders,
    body,
  });

  if (!r.ok) {
    const errText = await r.text().catch(() => "");
    throw new Error(`S3 PUT failed: ${r.status} ${errText}`);
  }
}

/* =========================
   Presigned GET (with token)
========================= */
function presignGet({ region, bucket, key }) {
  const AK = process.env.AWS_ACCESS_KEY_ID;
  const SK = process.env.AWS_SECRET_ACCESS_KEY;
  const ST = process.env.AWS_SESSION_TOKEN;

  if (!AK || !SK) throw new Error("Missing AWS credentials");
  if (!region) throw new Error("Missing S3_REGION env var");
  if (!bucket) throw new Error("Missing S3_BUCKET env var");

  const now = new Date();
  const amz = amzDate(now);
  const date = dateStamp(now);
  const scope = `${date}/${region}/s3/aws4_request`;

  const params = [
    ["X-Amz-Algorithm", "AWS4-HMAC-SHA256"],
    ["X-Amz-Credential", `${AK}/${scope}`],
    ["X-Amz-Date", amz],
    ["X-Amz-Expires", "3600"],
    ["X-Amz-SignedHeaders", "host"],
  ];
  if (ST) params.push(["X-Amz-Security-Token", ST]);

  params.sort(([a], [b]) => a.localeCompare(b));

  const query = params
    .map(([k, v]) => `${encodeURIComponent(k)}=${encodeURIComponent(v)}`)
    .join("&");

  const host = `${bucket}.s3.${region}.amazonaws.com`;
  const uri = `/${encodeURIComponent(key).replace(/%2F/g, "/")}`;

  const canonicalRequest =
    `GET\n${uri}\n${query}\nhost:${host}\n\nhost\nUNSIGNED-PAYLOAD`;

  const stringToSign =
    `AWS4-HMAC-SHA256\n${amz}\n${scope}\n${sha256Hex(canonicalRequest)}`;

  const sig = crypto
    .createHmac("sha256", signingKey(SK, date, region, "s3"))
    .update(stringToSign)
    .digest("hex");

  return `https://${host}${uri}?${query}&X-Amz-Signature=${sig}`;
}

/* =========================
   LAMBDA HANDLER (STABLE)
========================= */
export const handler = async (event) => {
  try {
    // ✅ Optional protection (disabled unless env var is set)
    maybeRequireApiKey(event);

    ensureGoogleCredsFile();

    // Parse body (API Gateway string body OR direct Lambda test)
    let body = {};
    if (typeof event?.body === "string") body = JSON.parse(event.body);
    else if (event?.body) body = event.body;
    else body = event;

    const action = body.action || (body.operationName ? "check" : "generate");

    const projectId = process.env.GOOGLE_CLOUD_PROJECT;
    const location = process.env.GOOGLE_LOCATION || "us-central1";
    const modelId = body.modelId || "veo-3.1-generate-001";

    if (!projectId) throw new Error("Missing GOOGLE_CLOUD_PROJECT env var");

    // Google Auth (WIF)
    const auth = new GoogleAuth({
      scopes: ["https://www.googleapis.com/auth/cloud-platform"],
    });
    const client = await auth.getClient();
    const token = (await client.getAccessToken()).token;
    if (!token) throw new Error("Failed to obtain Google access token");

    /* =========================
       ✅ ADD — STATUS (for UI sync after refresh)
       Called by webview: { action:"status", deviceId:"..." }
    ========================= */
    if (action === "status") {
      const deviceId = (body.deviceId || "").trim();
      if (!deviceId) {
        const err = new Error("Missing deviceId");
        err.statusCode = 400;
        throw err;
      }

      const st = await getTrialStatus(deviceId);

      return {
        statusCode: 200,
        headers: baseHeaders(),
        body: JSON.stringify({ ok: true, ...st }),
      };
    }

    /* ===== CHECK ===== */
    if (action === "check") {
      if (!body.operationName) throw new Error("Missing operationName for check");

      const r = await fetch(
        `https://${location}-aiplatform.googleapis.com/v1/projects/${projectId}/locations/${location}/publishers/google/models/${modelId}:fetchPredictOperation`,
        {
          method: "POST",
          headers: {
            Authorization: `Bearer ${token}`,
            "Content-Type": "application/json",
          },
          body: JSON.stringify({ operationName: body.operationName }),
        }
      );

      const data = await r.json();
      const b64 = data?.response?.videos?.[0]?.bytesBase64Encoded;

      if (!data.done || !b64) {
        return { statusCode: 200, headers: baseHeaders(), body: JSON.stringify(data) };
      }

      const video = Buffer.from(b64, "base64");

      const bucket = process.env.S3_BUCKET;
      const region = process.env.S3_REGION;
      const prefix = process.env.S3_PREFIX || "veo/";

      if (!bucket) throw new Error("Missing S3_BUCKET env var");
      if (!region) throw new Error("Missing S3_REGION env var");

      const key = `${prefix}veo-${Date.now()}-${crypto.randomUUID()}.mp4`;

      await s3Put({ region, bucket, key, body: video });
      const url = presignGet({ region, bucket, key });

      return {
        statusCode: 200,
        headers: baseHeaders(),
        body: JSON.stringify({
          done: true,
          bytes: video.length,
          s3: { bucket, key },
          downloadUrl: url,
          expiresInSeconds: 3600,
        }),
      };
    }

    /* ===== GENERATE ===== */
    // ✅ ADD: enforce trials ONLY on generate
    // Your webview already sends deviceId. If missing, we block.
    const deviceId = (body.deviceId || "").trim();
    if (!deviceId) {
      const err = new Error("Missing deviceId");
      err.statusCode = 400;
      throw err;
    }

    // Server-side trials: 2 per 24h (default), persists even after refresh
    await enforceTrials(deviceId);

    const prompt = body.prompt || "Cinematic 9:16 desert sunrise, realistic lighting";

    const gen = await fetch(
      `https://${location}-aiplatform.googleapis.com/v1/projects/${projectId}/locations/${location}/publishers/google/models/${modelId}:predictLongRunning`,
      {
        method: "POST",
        headers: {
          Authorization: `Bearer ${token}`,
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          instances: [{ prompt }],
          parameters: { aspectRatio: "9:16", durationSeconds: 8, sampleCount: 1 },
        }),
      }
    );

    return {
      statusCode: 200,
      headers: baseHeaders(),
      body: await gen.text(),
    };
  } catch (e) {
    console.error(e);
    const status = e.statusCode || 500;
    return {
      statusCode: status,
      headers: baseHeaders(),
      body: JSON.stringify({ error: e.message }),
    };
  }
};


